---
layout: single
title: "[C Language] - 포인터"
categories:
  - Language
date: 2023-05-01
last_modified_at: 
---

포인터란?
{: .notice--primary}

# Pointer 

## **포인터란?** 
- 메모리에 저장된 다른 변수의 주소값을 가르키는 변수이다.<br>
- 한 마디로 주소값을 저장하는 변수이다.<br>
- 포인터는 포인터 변수라고도 한다.<br>
- 포인터 변수도 메모리 공간을 갖는다.
- 포인터 변수를 이용하여 연결된 주소의 변수 영역을 접근할 수 있다.<br>

포인터 변수의 경우 데이터 값을 두 번의 접근이 필요해 간접접근이고, 일반 변수의 경우 한 번에 접근하여 직접접근이다.<br> 
{: .notice--warning} 

## **사용이유**
- 함수 작성에서 여러 개의 값을 리턴 받아야 할 때 
- 메모리 복사를 피하고 주소를 공유하여 비용을 아낄 때 
- 여러 개의 함수가 동일한 데이터를 공유하면서 작업할 때 

## **포인터에 쓰이는 연산자**<br>

**간접 참조 연산자(indirection operator)** (*)

- 간접 연산자, 간접접근 연산자, 역참조 연산자 다 똑같다.(indirection, dereference operator)

- 포인터가 가리키고 있는 주소의 데이터를 리턴하는 연산자이다. (주소를 통해 값에 접근)

포인터 변수를 선언할 때 사용되는 * 기호도 똑같은 연산자일까?<br>
{: .notice--warning}

**주소지정 연산자(address-of operator)** (&)

- 포인터 변수에 일반 변수 주소를 할당할 때 쓰인다.

- 변수의 주소가 리턴된다.<br>

## 사용 예

```c
int i = 10;
int *ptr;;
ptr = &i;
// 변수 선언과 값 지정을 나타내는 두 개의 문장
-----
int i = 10;
int *ptr = &i
// 두 개의 문장을 하나의 문장으로 만든다. 이것이 초기화 
```

<br>
**주의할 점**

```c
int aa = 10;
int *pointer;
*pointer = &aa; 
//포인터가 가르키는 영역에 aa의 주소값을 저장한다.
//포인터가 가르키는 영역이 없어 실행 시 문제가 발생한다.
int aa = 10;
int bb;
int *pointer = &bb
*pointer = &aa; 
-----
int aa = 10; 
int *pointer = aa; 
// 변수 선언과 동시에 aa의 주소가 아닌 일련의 값을 넣는다.
```

```c
// 포인터 변수에 저장할 주소는 포인터 변수와 자료형이 일치해야 한다. 
// 문자형 포인터 변수에는 문자형 변수의 주소를 저장할 수 있다는 뜻이다.
// 포인터 변수의 자료형은 포인터 자체의 자료형이 아니라 포인터에 저장할 일반 변수의 자료형이다.   

왜? 꼭 일치해야 할까?
포인터 변수에는 큰 자료형으로 쓰고 일반 변수의 자료형을 작을 것으로 쓰면 안되나?
short b = 10;
int *pointer = &b;

// 포인터 자료형의 크기는 
// 32bit 운영체에서는 4Byte (char, int, double 등 다 4Byte)
// 64bit 운영체제에서는 8Byte이다.(char, int, double 등 다 8Byte)

왜 다 똑같지?
```

```c
printf("??%d\n", &aa); // aa의 주소 출력
printf("??%d\n", pointer); // pointer가 가르키고 있는 주소 출력
printf("?%d\n", *pointer); // pointer가 가리키고 있는 주소의 일련의 값을 출력
printf("?%d\n", &pointer);// pointer의 주소를 출력
```