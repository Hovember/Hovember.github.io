---
layout: single
title: "[C Language] - 포인터"
categories:
  - Language
date: 2023-05-01
last_modified_at: 2023-06-14
---

포인터란?
{: .notice--primary}

# Pointer 

## **포인터란?** 

- 메모리에 저장된 다른 변수의 주소값을 가르키는 변수이다.<br>
- 한 마디로 주소값을 저장하는 변수이다.<br>
- 포인터는 포인터 변수라고도 한다.<br>
- 포인터 변수도 메모리 공간을 갖는다.
- 포인터 변수를 이용하여 연결된 주소의 변수 영역을 접근할 수 있다.<br>

포인터 변수의 경우 데이터 값을 두 번의 접근이 필요해 간접접근이고, 일반 변수의 경우 한 번에 접근하여 직접접근이다.<br> 
{: .notice--warning} 

## **사용이유**

- 함수 작성에서 여러 개의 값을 리턴 받아야 할 때 
- 메모리 복사를 피하고 주소를 공유하여 비용을 아낄 때
  - call by value, call by reference(C언어에서의 방식은 주소 값을 복사하여 전달해 엄밀히 말하면 call by value이다.)
- 여러 개의 함수가 동일한 데이터를 공유하면서 작업할 때 

## **포인터에 쓰이는 연산자**<br>

애스터리스크(Asterisk)와 앰퍼샌드(Ampersand) 는 대응된다.

**간접 참조 연산자(indirection operator)** (*)

- 간접 연산자, 간접접근 연산자, 역참조 연산자 다 똑같다.(indirection, dereference operator)

- 포인터가 가리키고 있는 주소의 데이터를 리턴하는 연산자이다. (주소를 통해 값에 접근)

포인터 변수를 선언할 때 사용되는 * 기호도 똑같은 연산자일까?<br>
같다고 한다!<br>
{: .notice--warning}

**주소지정 연산자(address-of operator)** (&)

- 포인터 변수에 일반 변수 주소를 할당할 때 쓰인다.

- 변수의 주소가 리턴된다.<br>

## 사용 예

```c
int i = 10;
int *ptr;; //정수형 포인터 ptr 
ptr = &i;
// 변수 선언과 값 지정을 나타내는 두 개의 문장
-----
int i = 10;
int *ptr = &i
// 두 개의 문장을 하나의 문장으로 만든다. 이것이 초기화 
```

<br>
**주의할 점**

```c
int aa = 10;
int *pointer;
*pointer = &aa; 
//포인터가 가르키는 영역에 aa의 주소값을 저장한다.
//포인터가 가르키는 영역이 없어 실행 시 문제가 발생한다.
int aa = 10;
int bb;
int *pointer = &bb
*pointer = &aa; 
-----
int aa = 10; 
int *pointer = aa; 
// 변수 선언과 동시에 aa의 주소가 아닌 일련의 값을 넣는다.
```

```c
// 포인터 변수에 저장할 주소는 포인터 변수와 자료형이 일치해야 한다. 
// 문자형 포인터 변수에는 문자형 변수의 주소를 저장할 수 있다는 뜻이다.
   
왜? 꼭 일치해야 할까?
이유는 프로그래밍상 오류를 방지하기 위해서이다. 
그래서 정수 포인터는 정수 데이터만 가리킬 수 있고, 
문자 포인터는 문자 데이터만 가리킬 수 있다. 

예를 들어 포인터 계산을 하면 
int int_array[5] = {1, 2, 3, 4, 5};
char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
char *char_pointer = int_array; //서로 맞지는 않는
int *int_pointer = char_array; // 데이터 타입을 가리킨다.
int_pointer+=1; 
char_pointer+=1;
printf("%c\n", *int_pointer); // e를 출력 
printf("%d\n", *char_pointer); //0을 출력, +4를 해야 2가 나온다. 
1 증가 시키는 것처럼 보이지만 포인터 변수의 데이터 타입 만큽 증가시킨다.  

// C언어는 데이터 타입에 대해 엄격하다.(그래서 속도가 빠르다.) 

포인터 변수에 자료형이 쓰이는 이유는 주소에 찾아 갔을 때 
자료형 만큼 메모리를 읽어야 하기 때문이다. 
만약 자료형이 없었다면 
무슨 자료형인지 몰라 몇 바이트를 읽어야 할 지 몰랐을 것이다. 

// 포인터 자료형의 크기는 
// 32bit 운영체제에서는 4Byte (char, int, double 등 다 4Byte)
// 64bit 운영체제에서는 8Byte이다.(char, int, double 등 다 8Byte)

왜 다 똑같지?
값을 저장하는 것이 아닌 주소값을 저장하기 때문이다.
32bit 운영체제에서 메모리 한 칸은 1Byte, 4Byte 길이의 주소를 갖고, 
2^32개의 주소를 표현할 수 있다. 0x00000000 ~ 0xFFFFFFFF
즉 메모리의 최대 크기는 4GB
64bit 운영체에서도 2^64(16EB엑사)개의 주소를 표현할 수 있기 때문에 포인터의 크기는 8Byte이다. 
```

```c
    int a = 10;
    int b = 20;

    const int* aa = &a; // 정수형 포인터가 상수, 상수 포인터 
    *aa = 20; //간접 참조(접근)하여 내부 값 변경 X

    int* const bb = &a; // bb가 상수, 포인터 상수
    bb = &b; // 포인터 변수의 주소 값 변경 X

    const int* const cc; // 둘 다 상수 
```

```c
    배열의 이름은 포인터

    int arry[5] = {1, 2, 3, 4, 5};

    // arry+3=50; // 배열은 주소값을 변경할 수 없다.  
    // arry=arry+1; // 연산 불가능,
    // arry++; // 한 곳만을 가리키고 있다.(const라고 보면 된다.)
    // 변경할 수 없는 포인터 = 배열 

    int *pa = arry;

    pa++;

    printf("%d\n", *pa); // 2

    printf("%d\n", *(pa++)); // 2

    printf("%d\n", *pa); // 3

    예를들어 arry는 100번지로 고정되어 있고, 포인터 pa는 100번지 였다가 104번지 였다가 할 수 있다. 
    
    포인터는 배열처럼 써도 된다. pa[0]
    
    포인터로 덧셈 뺄셈 가능 (자료형의 크기 만큼 증가 감소)
    포인터로 곱셈, 나눗셈, 나머지, 비트연산 등 불가능
    포인터끼리의 덧셈 불가능 ptr1 + ptr2 (불필요하기 때문)
    포인터끼리의 뺄셈 가능 ptr1 - ptr2 (ptr1과 ptr2의 사이의 거리)
    // 메모리상에서 얼마나 떨어져 있는지 구할 때 사용 
```

```c
// (*b)++와 *b++은 다르다.
// (*b)++ 값 증가
// *b++ 포인터 증가 

    int a[5] = {1, 2, 3, 4, 5};
    int *b = a;
    int i;
    
    printf("%d\n", (*b)++); //역참조 후 후위연산, [0]번에 1을 1증가,  출력: 1
    printf("%d\n", *b++); // 후위연산 후 역참조, b는 a[1]을 가리키게 됨  출력: 2
    printf("%d\n\n", *b); // 역참조, 출력: 2
```

```c
printf("??%d\n", &aa); // aa의 주소 출력
printf("??%d\n", pointer); // pointer가 가르키고 있는 주소 출력
printf("?%d\n", *pointer); // pointer가 가리키고 있는 주소의 일련의 값을 출력
printf("?%d\n", &pointer);// pointer의 주소를 출력
```


호출된 함수 내에서 배열의 크기를 구할 수 없는 이유
문자형에 정수형을 입력하면 왼쪽 3바이트는 버려지는 이유 
모든 문자는 아스키 코드 값으로 바귀어 숫자로 저장되고 연산되기 때문
{: .notice--warning} 